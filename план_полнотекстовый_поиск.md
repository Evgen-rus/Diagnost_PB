## Как «прикрутить» 3 FTS-чанка к уже работающему векторному поиску

> **Тезисно:**
>
> 1. Создаём FTS-таблицу, которая сама тянет текст из основной таблицы чанков.
> 2. Индексируем каждый чанк при вставке (одна строка кода или триггер).
> 3. При поиске делаем **два** независимых запроса:
>    • `top-3` из Faiss (у тебя уже есть)
>    • `top-3` из FTS5 (см. ниже)
> 4. Склеиваем списки, убирая дубли, и выдаём итог.

---

### 1. Таблицы: минимум кода

```sql
-- 1) «сырой» текст чанков
CREATE TABLE IF NOT EXISTS chunks (
    id     INTEGER PRIMARY KEY,
    text   TEXT
);

-- 2) FTS-индекс (берёт текст прямо из chunks)
CREATE VIRTUAL TABLE IF NOT EXISTS chunks_fts
USING fts5(                       -- встроенный движок
    text,                         -- поле, по которому ищем
    content='chunks',             -- источник данных
    content_rowid='id',           -- PK в chunks
    tokenize = "unicode61 remove_diacritics 2"   -- кириллица ок
);
```

> `unicode61` понимает русские буквы и префиксы (`поиск*`).
> Если нужен **стемминг**, придётся либо:
>
> * компилировать SQLite с ICU-tokenizer, либо
> * хранить в отдельной колонке «русифицированные» стемы (через `pymorphy2`) и индексировать их.
>   Для «максимально просто» обычно хватает настроек выше.

---

### 2. Индексация пачкой (as-is)

```python
async def add_chunk(text: str):
    async with aiosqlite.connect("db.sqlite") as db:
        cur = await db.execute("INSERT INTO chunks(text) VALUES (?)", (text,))
        chunk_id = cur.lastrowid
        # FTS-таблица сама увидит новую строку и проиндексирует
        await db.commit()
    return chunk_id
```

Если текст изменяется — делай `UPDATE chunks SET text=? WHERE id=?; INSERT INTO chunks_fts(chunks_fts) VALUES('optimize');`

---

### 3. Поиск: топ-3 FTS

```python
async def fts_search(query: str, limit: int = 3):
    sql = """
    SELECT
        rowid AS id,
        bm25(chunks_fts) AS rank,                        -- релевантность
        snippet(chunks_fts, 0, '<b>', '</b>', ' … ', 10) AS snippet
    FROM chunks_fts
    WHERE chunks_fts MATCH ?
    ORDER BY rank                                        -- чем меньше, тем лучше
    LIMIT ?
    """
    async with aiosqlite.connect("db.sqlite") as db, db.execute(sql, (query, limit)) as cur:
        return await cur.fetchall()     # [(id, rank, snippet), …]
```

---

### 4. Объединяем c Faiss-результатами

```python
def merge_results(vec_ids: list[int], fts_rows: list[tuple]) -> list[int]:
    seen = set()
    merged = []

    # 1) сначала векторные (сохраняем порядок)
    for i in vec_ids:
        if i not in seen:
            merged.append(i)
            seen.add(i)

    # 2) затем FTS
    for row in fts_rows:
        i = row[0]          # id из БД
        if i not in seen:
            merged.append(i)
            seen.add(i)

    return merged           # итоговый список id без дублей
```

Использование:

```python
vec_ids = vector_search(embedding, top_k=3)      # уже есть у тебя
fts_rows = await fts_search("поиск*", limit=3)   # топ-3 по ключевым словам
result_ids = merge_results(vec_ids, fts_rows)
```

---

### 5. Что ещё учесть / частые вопросы

| Вопрос                                          | Короткий ответ                                                                                          |
| ----------------------------------------------- | ------------------------------------------------------------------------------------------------------- |
| **Почему `unicode61`, а не Porter?**            | Porter встроен, но русские суффиксы почти не режет; unicode61 надёжно токенизирует кириллицу.           |
| **Нужен морфо-поиск («купить/купил/покупка»)?** | Сделай отдельное поле `stemmed`, куда кладёшь стемы `pymorphy2` → `fts5(stemmed)` → ищешь по нему.      |
| **Как подсветить совпадения?**                  | В примере выше уже есть `snippet()` — возвращай его в ответ, чтобы выдать отрывок с `<b>…</b>`.         |
| **Как не забыть про массовую заливку?**         | После bulk-insert вызови `INSERT INTO chunks_fts(chunks_fts) VALUES('optimize');` — пересчитает индекс. |
| **Насколько быстро?**                           | На \~100 000 чанков поиск ≤ 5 мс локально; времени на Faiss обычно больше.                              |

---

### 6. Итог

1. **Одна FTS-таблица** + пара строк кода при вставке.
2. **Два параллельных запроса** (Faiss + FTS).
3. **Склеиваем** списки, выбрасывая дубли — получаем до 6 уникальных чанков (3 семантика + 3 лексика).

Так ты закрываешь оба кейса:
*«найти по смыслу»* и *«поймать точную фразу / редкое слово»* — без тяжёлых внешних сервисов.